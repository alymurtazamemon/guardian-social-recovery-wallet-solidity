{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nerror Error__AddressAlreadyAnOwner(string location, address addr);\nerror Error__GuardiansListIsEmpty(string location);\nerror Error__AddressNotFoundAsGuardian(string location, address addr);\nerror Error__UpdateNotRequested(string location);\nerror Error__AlreadyConfirmedByGuardian(string location, address guardian);\nerror Error__RequestTimeExpired(string location);\nerror Error__InvalidAmount(string location, uint amount);\nerror Error__DailyTransferLimitExceed(string location, uint amount);\nerror Error__TransactionFailed(string location);\nerror Error__BalanceIsZero(string location, uint balance);\nerror Error__InvalidLimit(string location, uint256 limit);\nerror Error__UpdateNotRequestedByOwner(string location);\nerror Error__RequiredConfirmationsNotMet(\n    string location,\n    uint256 confirmations\n);\nerror Error__InvalidGuardiansList(string location, address[] addressesList);\nerror Error__CanOnlyChangeAfterDelayPeriod(string location);\nerror Error__GuardianDoesNotExist(string location);\nerror Error__CanOnlyRemoveAfterDelayPeriod(string location);\nerror Error__CanOnlyAddAfterDelayPeriod(string location);\n"
    },
    "contracts/FundsManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./GuardiansManager.sol\";\nimport \"./Errors.sol\";\n\ncontract FundsManager is GuardiansManager {\n    // * STATE VARIABLES\n    uint256 private dailyTransferLimit;\n    uint256 private tempDailyTransferLimit;\n    uint256 private lastDailyTransferUpdateRequestTime;\n    uint256 private dailyTransferLimitUpdateConfirmationTime;\n\n    bool private isDailyTransferLimitUpdateRequested;\n\n    mapping(address => bool) private isConfirmedByGuardian;\n\n    AggregatorV3Interface private priceFeed;\n\n    // * FUNCTIONS\n    constructor(address _priceFeed) {\n        priceFeed = AggregatorV3Interface(_priceFeed);\n        dailyTransferLimit = 1 ether;\n        dailyTransferLimitUpdateConfirmationTime = 1 days;\n    }\n\n    // * FUNCTIONS - EXTERNAL\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    function send(address to, uint amount) external onlyOwner nonReentrant {\n        if (amount <= 0) {\n            revert Error__InvalidAmount(\"FundsManager\", amount);\n        }\n\n        if (amount > dailyTransferLimit) {\n            revert Error__DailyTransferLimitExceed(\"FundsManager\", amount);\n        }\n\n        (bool success, ) = to.call{value: amount}(\"\");\n        if (!success) {\n            revert Error__TransactionFailed(\"FundsManager\");\n        }\n    }\n\n    function sendAll(address to) external onlyOwner nonReentrant {\n        uint256 balance = address(this).balance;\n\n        if (balance <= 0) {\n            revert Error__BalanceIsZero(\"FundsManager\", balance);\n        }\n\n        if (balance > dailyTransferLimit) {\n            revert Error__DailyTransferLimitExceed(\"FundsManager\", balance);\n        }\n\n        (bool success, ) = to.call{value: balance}(\"\");\n        if (!success) {\n            revert Error__TransactionFailed(\"FundsManager\");\n        }\n    }\n\n    function requestToUpdateDailyTransferLimit(\n        uint256 limit\n    ) external onlyOwner {\n        if (limit <= 0) {\n            revert Error__InvalidLimit(\"FundsManager\", limit);\n        }\n\n        lastDailyTransferUpdateRequestTime = block.timestamp;\n        tempDailyTransferLimit = limit;\n        isDailyTransferLimitUpdateRequested = true;\n    }\n\n    function confirmDailyTransferLimitRequest() external {\n        if (guardians.length <= 0) {\n            revert Error__GuardiansListIsEmpty(\"FundsManager\");\n        }\n\n        if (!isDailyTransferLimitUpdateRequested) {\n            revert Error__UpdateNotRequestedByOwner(\"FundsManager\");\n        }\n\n        if (\n            block.timestamp >\n            lastDailyTransferUpdateRequestTime +\n                dailyTransferLimitUpdateConfirmationTime\n        ) {\n            resetDailyTransferLimitVariables();\n            revert Error__RequestTimeExpired(\"FundsManager\");\n        }\n\n        if (isConfirmedByGuardian[msg.sender]) {\n            revert Error__AlreadyConfirmedByGuardian(\n                \"FundsManager\",\n                msg.sender\n            );\n        }\n\n        if (!doesGuardianExist(msg.sender)) {\n            revert Error__AddressNotFoundAsGuardian(\"FundsManager\", msg.sender);\n        }\n\n        isConfirmedByGuardian[msg.sender] = true;\n    }\n\n    function confirmAndUpdate() external onlyOwner {\n        if (guardians.length <= 0) {\n            revert Error__GuardiansListIsEmpty(\"FundsManager\");\n        }\n\n        if (!isDailyTransferLimitUpdateRequested) {\n            revert Error__UpdateNotRequestedByOwner(\"FundsManager\");\n        }\n\n        if (\n            block.timestamp >\n            lastDailyTransferUpdateRequestTime +\n                dailyTransferLimitUpdateConfirmationTime\n        ) {\n            resetDailyTransferLimitVariables();\n            revert Error__RequestTimeExpired(\"FundsManager\");\n        }\n\n        address[] memory guardiansCopy = guardians;\n        uint256 counter = 0;\n\n        for (uint256 i = 0; i < guardiansCopy.length; i++) {\n            if (isConfirmedByGuardian[guardiansCopy[i]]) {\n                counter++;\n            }\n        }\n\n        if (counter < requiredConfirmations) {\n            revert Error__RequiredConfirmationsNotMet(\n                \"FundsManager\",\n                requiredConfirmations\n            );\n        }\n\n        dailyTransferLimit = tempDailyTransferLimit;\n\n        resetDailyTransferLimitVariables();\n    }\n\n    function updateETHUSDPriceFeed(address _priceFeed) external onlyOwner {\n        priceFeed = AggregatorV3Interface(_priceFeed);\n    }\n\n    // * FUNCTIONS - PRIVATE\n\n    function resetDailyTransferLimitVariables() private {\n        isDailyTransferLimitUpdateRequested = false;\n\n        address[] memory guardiansCopy = guardians;\n\n        for (uint256 i = 0; i < guardiansCopy.length; i++) {\n            if (isConfirmedByGuardian[guardiansCopy[i]]) {\n                isConfirmedByGuardian[guardiansCopy[i]] = false;\n            }\n        }\n    }\n\n    // * FUNCTIONS - VIEW & PURE - EXTERNAL\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getBalanceInUSD() external view returns (uint256) {\n        uint256 ethPrice = getPrice();\n        uint256 balanceInUSD = (ethPrice * address(this).balance) /\n            1000000000000000000;\n        return balanceInUSD;\n    }\n\n    function getDailyTransferLimit() external view returns (uint256) {\n        return dailyTransferLimit;\n    }\n\n    function getRequiredConfirmations() external view returns (uint256) {\n        return requiredConfirmations;\n    }\n\n    function getDailyTransferLimitUpdateRequestStatus()\n        external\n        view\n        returns (bool)\n    {\n        return isDailyTransferLimitUpdateRequested;\n    }\n\n    function getDailyTransferLimitUpdateConfirmationTime()\n        external\n        view\n        returns (uint256)\n    {\n        return dailyTransferLimitUpdateConfirmationTime;\n    }\n\n    function getLastDailyTransferUpdateRequestTime()\n        external\n        view\n        returns (uint256)\n    {\n        return lastDailyTransferUpdateRequestTime;\n    }\n\n    function getGuardianConfirmationStatus(\n        address guardian\n    ) external view returns (bool) {\n        return isConfirmedByGuardian[guardian];\n    }\n\n    // * FUNCTIONS - VIEW & PURE - PRIVATE\n\n    function getPrice() private view returns (uint256) {\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        // ETH/USD rate in 18 digit\n        return uint256(answer * 10000000000);\n    }\n}\n"
    },
    "contracts/Guardian.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"./FundsManager.sol\";\nimport \"./OwnershipManager.sol\";\n\ncontract Guardian is FundsManager, OwnershipManager {\n    constructor(address priceFeed) FundsManager(priceFeed) {}\n}\n"
    },
    "contracts/GuardiansManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./Errors.sol\";\n\ncontract GuardiansManager is Ownable, ReentrancyGuard {\n    // * STATE VARIABLES\n    uint256 private addGuardianDelay;\n    uint256 private lastGuardianAddTime;\n    uint256 private changeGuardianDelay;\n    uint256 private lastGuardianChangeTime;\n    uint256 private removeGuardianDelay;\n    uint256 private lastGuardianRemovalTime;\n\n    uint256 internal requiredConfirmations;\n\n    address[] internal guardians;\n\n    // * FUNCTIONS\n    constructor() {\n        lastGuardianAddTime = block.timestamp;\n        addGuardianDelay = 1 days;\n        lastGuardianChangeTime = block.timestamp;\n        changeGuardianDelay = 1 days;\n        lastGuardianRemovalTime = block.timestamp;\n        removeGuardianDelay = 3 days;\n    }\n\n    // * FUNCTIONS - EXTERNAL\n    function addGuardian(address guardian) external onlyOwner nonReentrant {\n        if (block.timestamp < lastGuardianAddTime + addGuardianDelay) {\n            revert Error__CanOnlyAddAfterDelayPeriod(\"GuardiansManager\");\n        }\n\n        guardians.push(guardian);\n        lastGuardianAddTime = block.timestamp;\n        updateRequiredConfirmations();\n    }\n\n    function changeGuardian(\n        address from,\n        address to\n    ) external onlyOwner nonReentrant {\n        if (block.timestamp < lastGuardianChangeTime + changeGuardianDelay) {\n            revert Error__CanOnlyChangeAfterDelayPeriod(\"GuardiansManager\");\n        }\n\n        address[] memory guardiansCopy = guardians;\n\n        // * using this variable so we should not update the state variable if address does not exits.\n        bool exist = false;\n\n        for (uint256 i = 0; i < guardiansCopy.length; i++) {\n            if (guardiansCopy[i] == from) {\n                exist = true;\n                guardiansCopy[i] = to;\n                break;\n            }\n        }\n\n        if (exist) {\n            guardians = guardiansCopy;\n            lastGuardianChangeTime = block.timestamp;\n        } else {\n            revert Error__GuardianDoesNotExist(\"GuardiansManager\");\n        }\n    }\n\n    function removeGuardian(address guardian) external onlyOwner nonReentrant {\n        if (block.timestamp < lastGuardianRemovalTime + removeGuardianDelay) {\n            revert Error__CanOnlyRemoveAfterDelayPeriod(\"GuardiansManager\");\n        }\n\n        if (guardians.length <= 0) {\n            revert Error__GuardiansListIsEmpty(\"GuardiansManager\");\n        }\n\n        address[] memory guardiansCopy = guardians;\n\n        // * for local arrays we need to declare the size at the initialization time.\n        // * we are removing the 1 guardian so the updated array will be less than 1 the length of existing array.\n        address[] memory updatedCopy = new address[](guardiansCopy.length - 1);\n        uint256 index = 0;\n\n        // * using this variable so we should not update the state variable if address does not exits.\n        bool exist = false;\n\n        for (uint256 i = 0; i < guardiansCopy.length; i++) {\n            if (guardiansCopy[i] == guardian) {\n                exist = true;\n                continue;\n            } else if (i != updatedCopy.length) {\n                updatedCopy[index] = guardiansCopy[i];\n                index++;\n            }\n        }\n\n        if (exist) {\n            guardians = updatedCopy;\n            lastGuardianRemovalTime = block.timestamp;\n        } else {\n            revert Error__GuardianDoesNotExist(\"GuardiansManager\");\n        }\n    }\n\n    // * FUNCTION - PRIVATE\n\n    function updateRequiredConfirmations() private {\n        requiredConfirmations = (guardians.length / 2) + 1;\n    }\n\n    // * FUNCTIONS - VIEW & PURE - EXTERNAL\n\n    function getLastGuardianAddTime() external view returns (uint256) {\n        return lastGuardianAddTime;\n    }\n\n    function getAddGuardianDelay() external view returns (uint256) {\n        return addGuardianDelay;\n    }\n\n    function getLastGuardianChangeTime() external view returns (uint256) {\n        return lastGuardianChangeTime;\n    }\n\n    function getChangeGuardianDelay() external view returns (uint256) {\n        return changeGuardianDelay;\n    }\n\n    function getLastGuardianRemovalTime() external view returns (uint256) {\n        return lastGuardianRemovalTime;\n    }\n\n    function getRemoveGuardianDelay() external view returns (uint256) {\n        return removeGuardianDelay;\n    }\n\n    function getGuardians() external view returns (address[] memory) {\n        return guardians;\n    }\n\n    // * FUNCTIONS - VIEW & PURE - INTERNAL\n\n    function doesGuardianExist(address caller) internal view returns (bool) {\n        address[] memory guardiansCopy = guardians;\n\n        for (uint256 i = 0; i < guardiansCopy.length; i++) {\n            if (caller == guardiansCopy[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"
    },
    "contracts/OwnershipManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./GuardiansManager.sol\";\nimport \"./Errors.sol\";\n\npragma solidity ^0.8.17;\n\ncontract OwnershipManager is GuardiansManager {\n    // * STATE VARIABLES\n    uint256 private lastOwnerUpdateRequestTime;\n    uint256 private ownerUpdateConfirmationTime;\n    uint256 private noOfConfirmations;\n\n    bool private isOwnerUpdateRequested;\n\n    address private tempAddress;\n\n    mapping(address => bool) private isOwnershipConfimedByGuardian;\n\n    // * FUNCTIONS\n    constructor() {\n        ownerUpdateConfirmationTime = 2 hours;\n    }\n\n    function requestToUpdateOwner(address newOwnerAddress) external {\n        if (newOwnerAddress == owner()) {\n            revert Error__AddressAlreadyAnOwner(\n                \"OwnershipManager\",\n                newOwnerAddress\n            );\n        }\n\n        if (guardians.length <= 0) {\n            revert Error__GuardiansListIsEmpty(\"OwnershipManager\");\n        }\n\n        if (!doesGuardianExist(msg.sender)) {\n            revert Error__AddressNotFoundAsGuardian(\n                \"OwnershipManager\",\n                msg.sender\n            );\n        }\n\n        lastOwnerUpdateRequestTime = block.timestamp;\n        tempAddress = newOwnerAddress;\n        isOwnershipConfimedByGuardian[msg.sender] = true;\n        noOfConfirmations++;\n        isOwnerUpdateRequested = true;\n    }\n\n    function confirmUpdateOwnerRequest() external {\n        if (guardians.length <= 0) {\n            revert Error__GuardiansListIsEmpty(\"OwnershipManager\");\n        }\n\n        if (!isOwnerUpdateRequested) {\n            revert Error__UpdateNotRequested(\"OwnershipManager\");\n        }\n\n        if (isOwnershipConfimedByGuardian[msg.sender]) {\n            revert Error__AlreadyConfirmedByGuardian(\n                \"OwnershipManager\",\n                msg.sender\n            );\n        }\n\n        if (\n            block.timestamp >\n            lastOwnerUpdateRequestTime + ownerUpdateConfirmationTime\n        ) {\n            resetOwnershipVariables();\n            revert Error__RequestTimeExpired(\"OwnershipManager\");\n        }\n\n        if (!doesGuardianExist(msg.sender)) {\n            revert Error__AddressNotFoundAsGuardian(\n                \"OwnershipManager\",\n                msg.sender\n            );\n        }\n\n        isOwnershipConfimedByGuardian[msg.sender] = true;\n        noOfConfirmations++;\n\n        if (noOfConfirmations >= requiredConfirmations) {\n            // * Ownable internal function without access restriction.\n            _transferOwnership(tempAddress);\n            resetOwnershipVariables();\n        }\n    }\n\n    // * FUNCTION - PRIVATE\n    function resetOwnershipVariables() private {\n        isOwnerUpdateRequested = false;\n        noOfConfirmations = 0;\n\n        address[] memory guardiansCopy = guardians;\n\n        for (uint256 i = 0; i < guardiansCopy.length; i++) {\n            if (isOwnershipConfimedByGuardian[guardiansCopy[i]]) {\n                isOwnershipConfimedByGuardian[guardiansCopy[i]] = false;\n            }\n        }\n    }\n\n    // * FUNCTION - VIEW & PURE\n    function getIsOwnerUpdateRequested() external view returns (bool) {\n        return isOwnerUpdateRequested;\n    }\n\n    function getIsOwnershipConfimedByGuardian(\n        address guardian\n    ) external view returns (bool) {\n        return isOwnershipConfimedByGuardian[guardian];\n    }\n\n    function getLastOwnerUpdateRequestTime() external view returns (uint256) {\n        return lastOwnerUpdateRequestTime;\n    }\n\n    function getOwnerUpdateConfirmationTime() external view returns (uint256) {\n        return ownerUpdateConfirmationTime;\n    }\n\n    function getNoOfConfirmations() external view returns (uint256) {\n        return noOfConfirmations;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}